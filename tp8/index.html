<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>TP - Eclairage</title>
<style>
    body { margin: 0; }
    canvas { width: 100%; height: 100% }
    .centre{text-align: center;}
    </style>
</head>
<body>
<!-- API importé du site de Three.js -->
<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
<script type="importmap">
{
"imports": {
"three": "https://threejs.org/build/three.module.js",
"three/addons/": "https://threejs.org/examples/jsm/"
}
}
</script>
<!-- Un titre centré -->
<h1 class="centre"> TP 3 - Modelisation</h1>

<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>



<script type="module" src="TeapotGeometry.js"></script>
<script type="text/x-glsl" id="vertex">
    varying vec3 vNormal;
    varying vec3 vViewPosition;
    
    void main() {
        
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        vNormal = normalize( normalMatrix * normal );
        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
        vViewPosition = -mvPosition.xyz;
        
        }
        </script>
        <script type="text/x-glsl" id="fragment">
            uniform vec3 uMaterialColor;
            
            uniform vec3 uDirLightPos;
            uniform vec3 uDirLightColor;
            
            uniform float uKd;
            uniform float uBorder;
            
            varying vec3 vNormal;
            varying vec3 vViewPosition;
            
            void main() {
                // compute direction to light
                vec4 lDirection = viewMatrix * vec4( uDirLightPos, 0.0 );
                vec3 lVector = normalize( lDirection.xyz );
                
                // diffuse: N * L. Normal must be normalized, since it's interpolated.
                vec3 normal = normalize( vNormal );
                
                // Student: check the diffuse dot product against uBorder and adjust
                // this diffuse value accordingly.
                //float diffuse = max( dot( normal, lVector ), 0.0);
                float diffuse;
                if(dot(normal, lVector) > 0.6) {
                    diffuse = 1.0;
                    }
                    else if(dot(normal, lVector) < -0.2) {
                        diffuse = 0.3;
                        }
                        else {
                            diffuse = 0.7;
                            }
                            
                            if(uBorder > dot(normal, lVector)) {
                                diffuse = 0.5;
                                }
                                else {
                                    
                                    diffuse = 1.0;
                                    }
                                    
                                    
                                    gl_FragColor = vec4( uKd * uMaterialColor * uDirLightColor * diffuse, 1.0 );
                                    }
                                    </script>
                                    
                                    <!-- Pour mettre le rendu Web GL centré -->
                                    <div id="webGL" class="centre"></div>
                                    
                                    <div id="container" onclick="this.focus();"></div>
                                    <div id="grading"></div>
                                    <p class="centre"> Exercice 3.a </p>
                                    
                                    <!-- Mon script avec un chemin relatif -->
                                    <script  type='module' src="ex1.js"></script>
                                    </body>
                                    </html>